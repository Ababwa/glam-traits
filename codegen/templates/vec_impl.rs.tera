{%- if strong_t %}
	{%- set temp_strong_t_upper = strong_t | upper %}
	{%- set base_name = temp_strong_t_upper ~ "Vec" %}
	{%- if strong_t == "i16" %}
		{%- set is_int = true %}
		{%- set is_signed = true %}
	{%- elif strong_t == "u16" %}
		{%- set is_int = true %}
		{%- set is_unsigned = true %}
	{%- elif strong_t == "i32" %}
		{%- set is_int = true %}
		{%- set is_signed = true %}
	{%- elif strong_t == "u32" %}
		{%- set is_int = true %}
		{%- set is_unsigned = true %}
	{%- elif strong_t == "i64" %}
		{%- set is_int = true %}
		{%- set is_signed = true %}
	{%- elif strong_t == "u64" %}
		{%- set is_int = true %}
		{%- set is_unsigned = true %}
	{%- elif strong_t == "f32" %}
		{%- set is_float = true %}
		{%- set is_signed = true %}
	{%- elif strong_t == "f64" %}
		{%- set is_float = true %}
		{%- set is_signed = true %}
	{%- endif %}
{%- elif is_float %}
	{%- set base_name = "FloatVec" %}
{%- elif is_int %}
	{%- if is_signed %}
		{%- set base_name = "SIntVec" %}
	{%- elif is_unsigned %}
		{%- set base_name = "UIntVec" %}
	{%- else %}
		{%- set base_name = "IntVec" %}
	{%- endif %}
{%- elif is_signed %}
	{%- set base_name = "SignedVec" %}
{%- else %}
	{%- set base_name = "GVec" %}
{%- endif -%}

{%- if dim %}
	{%- set name = base_name ~ dim %}
	{%- set components = ["x", "y", "z", "w"] | slice(end = dim) %}
	{%- set dim_minus_one = dim - 1 %}
	{%- set dim_plus_one = dim + 1 %}
	{%- if dim == 2 %}
		{%- set bvec_t = "glam::BVec2" %}
	{%- else %}
		{%- set bvec_t = "Self::BVec" ~ dim ~ "Type" %}
	{%- endif %}
{%- else %}
	{%- set name = base_name %}
	{%- set bvec_t = "Self::BVecType" %}
{%- endif %}

{%- if strong_t %}
	{%- set scalar_t = strong_t %}
{%- else %}
	{%- set scalar_t = "Self::Scalar" %}
{%- endif %}
impl {{ name }} for glam::{{ impl_t }} {
{%- if not strong_t %}
	type Scalar = {{ impl_scalar_t }};
{%- endif %}
{%- if dim %}
	{%- if dim > 2 %}
	type BVec{{ dim }}Type = glam::{{ impl_bvec_t }};
	type {{ base_name ~ dim_minus_one }}Type = glam::{{ impl_minus_one_t }};
	{%- endif %}
	{%- if dim < 4 %}
	type {{ base_name ~ dim_plus_one }}Type = glam::{{ impl_plus_one_t }};
	{%- endif %}
{%- else %}
	type BVecType = glam::{{ impl_bvec_t }};
{%- endif %}
	const ZERO: Self = Self::ZERO;
	const ONE: Self = Self::ONE;
{%- if is_signed %}
	const NEG_ONE: Self = Self::NEG_ONE;
{%- endif %}
	const MIN: Self = Self::MIN;
	const MAX: Self = Self::MAX;
{%- if is_float %}
	const NAN: Self = Self::NAN;
	const INFINITY: Self = Self::INFINITY;
	const NEG_INFINITY: Self = Self::NEG_INFINITY;
{%- endif %}
{%- if dim %}
	{%- for c in components %}
	const {{ c | upper }}: Self = Self::{{ c | upper }};
	{%- endfor %}
	{%- if is_signed %}
		{%- for c in components %}
	const NEG_{{ c | upper }}: Self = Self::NEG_{{ c | upper }};
		{%- endfor %}
	{%- endif %}
	const AXES: [Self; {{ dim }}] = Self::AXES;
{%- else %}
	const DIM: usize = {{ impl_dim }};
{%- endif %}
	fn splat(v: {{ scalar_t }}) -> Self { Self::splat(v) }
	fn from_slice(slice: &[{{ scalar_t }}]) -> Self { Self::from_slice(slice) }
	fn write_to_slice(self, slice: &mut [{{ scalar_t }}]) { self.write_to_slice(slice) }
	fn dot(self, rhs: Self) -> {{ scalar_t }} { self.dot(rhs) }
	fn dot_into_vec(self, rhs: Self) -> Self { self.dot_into_vec(rhs) }
	fn min(self, rhs: Self) -> Self { self.min(rhs) }
	fn max(self, rhs: Self) -> Self { self.max(rhs) }
	fn clamp(self, min: Self, max: Self) -> Self { self.clamp(min, max) }
	fn min_element(self) -> {{ scalar_t }} { self.min_element() }
	fn max_element(self) -> {{ scalar_t }} { self.max_element() }
	fn element_sum(self) -> {{ scalar_t }} { self.element_sum() }
	fn element_product(self) -> {{ scalar_t }} { self.element_product() }
	fn select(mask: {{ bvec_t }}, if_true: Self, if_false: Self) -> Self { Self::select(mask, if_true, if_false) }
	fn cmpeq(self, rhs: Self) -> {{ bvec_t }} { self.cmpeq(rhs) }
	fn cmpne(self, rhs: Self) -> {{ bvec_t }} { self.cmpne(rhs) }
	fn cmpge(self, rhs: Self) -> {{ bvec_t }} { self.cmpge(rhs) }
	fn cmpgt(self, rhs: Self) -> {{ bvec_t }} { self.cmpgt(rhs) }
	fn cmple(self, rhs: Self) -> {{ bvec_t }} { self.cmple(rhs) }
	fn cmplt(self, rhs: Self) -> {{ bvec_t }} { self.cmplt(rhs) }
	fn length_squared(self) -> {{ scalar_t }} { self.length_squared() }
{%- if is_signed %}
	fn abs(self) -> Self { self.abs() }
	fn signum(self) -> Self { self.signum() }
	fn is_negative_bitmask(self) -> u32 { self.is_negative_bitmask() }
	fn distance_squared(self, rhs: Self) -> {{ scalar_t }} { self.distance_squared(rhs) }
	fn div_euclid(self, rhs: Self) -> Self { self.div_euclid(rhs) }
	fn rem_euclid(self, rhs: Self) -> Self { self.rem_euclid(rhs) }
{%- endif %}
{%- if is_float %}
	fn copysign(self, rhs: Self) -> Self { self.copysign(rhs) }
	fn is_finite(self) -> bool { self.is_finite() }
	fn is_nan(self) -> bool { self.is_nan() }
	fn length(self) -> {{ scalar_t }} { self.length() }
	fn length_recip(self) -> {{ scalar_t }} { self.length_recip() }
	fn distance(self, rhs: Self) -> {{ scalar_t }} { self.distance(rhs) }
	fn normalize(self) -> Self { self.normalize() }
	fn try_normalize(self) -> Option<Self> { self.try_normalize() }
	fn normalize_or_zero(self) -> Self { self.normalize_or_zero() }
	fn is_normalized(self) -> bool { self.is_normalized() }
	fn project_onto(self, rhs: Self) -> Self { self.project_onto(rhs) }
	fn reject_from(self, rhs: Self) -> Self { self.reject_from(rhs) }
	fn project_onto_normalized(self, rhs: Self) -> Self { self.project_onto_normalized(rhs) }
	fn reject_from_normalized(self, rhs: Self) -> Self { self.reject_from_normalized(rhs) }
	fn round(self) -> Self { self.round() }
	fn floor(self) -> Self { self.floor() }
	fn ceil(self) -> Self { self.ceil() }
	fn trunc(self) -> Self { self.trunc() }
	fn fract(self) -> Self { self.fract() }
	fn exp(self) -> Self { self.exp() }
	fn powf(self, n: {{ scalar_t }}) -> Self { self.powf(n) }
	fn recip(self) -> Self { self.recip() }
	fn lerp(self, rhs: Self, s: {{ scalar_t }}) -> Self { self.lerp(rhs, s) }
	fn midpoint(self, rhs: Self) -> Self { self.midpoint(rhs) }
	fn abs_diff_eq(self, rhs: Self, max_abs_diff: {{ scalar_t }}) -> bool { self.abs_diff_eq(rhs, max_abs_diff) }
	fn clamp_length(self, min: {{ scalar_t }}, max: {{ scalar_t }}) -> Self { self.clamp_length(min, max) }
	fn clamp_length_max(self, max: {{ scalar_t }}) -> Self { self.clamp_length_max(max) }
	fn clamp_length_min(self, min: {{ scalar_t }}) -> Self { self.clamp_length_min(min) }
	fn mul_add(self, a: Self, b: Self) -> Self { self.mul_add(a, b) }
{%- endif %}
{%- if is_int %}
	fn wrapping_add(self, rhs: Self) -> Self { self.wrapping_add(rhs) }
	fn wrapping_sub(self, rhs: Self) -> Self { self.wrapping_sub(rhs) }
	fn wrapping_mul(self, rhs: Self) -> Self { self.wrapping_mul(rhs) }
	fn wrapping_div(self, rhs: Self) -> Self { self.wrapping_div(rhs) }
	fn saturating_add(self, rhs: Self) -> Self { self.saturating_add(rhs) }
	fn saturating_sub(self, rhs: Self) -> Self { self.saturating_sub(rhs) }
	fn saturating_mul(self, rhs: Self) -> Self { self.saturating_mul(rhs) }
	fn saturating_div(self, rhs: Self) -> Self { self.saturating_div(rhs) }
{%- endif %}
{%- if dim %}
	fn new({% for c in components %}{{ c }}: Self::Scalar{% if not loop.last %}, {% endif %}{% endfor %}) -> Self { Self::new({% for c in components %}{{ c }}{% if not loop.last %}, {% endif %}{% endfor %}) }
	fn from_array(a: [Self::Scalar; {{ dim }}]) -> Self { Self::from_array(a) }
	fn to_array(&self) -> [Self::Scalar; {{ dim }}] { self.to_array() }
	{%- if dim < 4 %}
	fn extend(self, v: Self::Scalar) -> Self::{{ base_name ~ dim_plus_one }}Type { self.extend(v) }
	{%- endif %}
	{%- if dim > 2 %}
	fn truncate(self) -> Self::{{ base_name ~ dim_minus_one }}Type { self.truncate() }
	{%- endif %}
	{%- if dim == 3 %}
	fn cross(self, rhs: Self) -> Self { self.cross(rhs) }
	{%- endif %}
	{%- if is_signed %}
		{%- if dim == 2 %}
	fn perp(self) -> Self { self.perp() }
	fn perp_dot(self, rhs: Self) -> Self::Scalar { self.perp_dot(rhs) }
	fn rotate(self, rhs: Self) -> Self { self.rotate(rhs) }
		{%- endif %}
	{%- endif %}
	{%- if is_float %}
	fn is_nan_mask(self) -> {{ bvec_t }} { self.is_nan_mask() }
		{%- if dim < 4 %}
	fn angle_between(self, rhs: Self) -> Self::Scalar { self.angle_between(rhs) }
		{%- endif %}
		{%- if dim == 2 %}
	fn from_angle(angle: Self::Scalar) -> Self { Self::from_angle(angle) }
	fn to_angle(self) -> Self::Scalar { self.to_angle() }
		{%- elif dim == 3 %}
	fn any_orthogonal_vector(&self) -> Self { self.any_orthogonal_vector() }
	fn any_orthonormal_vector(&self) -> Self { self.any_orthonormal_vector() }
	fn any_orthonormal_pair(&self) -> (Self, Self) { self.any_orthonormal_pair() }
		{%- endif %}
	{%- endif %}
{%- endif %}
}
