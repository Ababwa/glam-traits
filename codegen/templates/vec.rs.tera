{%- if strong_t %}
	{%- set temp_strong_t_upper = strong_t | upper %}
	{%- set base_name = temp_strong_t_upper ~ "Vec" %}
	{%- if strong_t == "i16" %}
		{%- set is_int = true %}
		{%- set is_signed = true %}
	{%- elif strong_t == "u16" %}
		{%- set is_int = true %}
		{%- set is_unsigned = true %}
	{%- elif strong_t == "i32" %}
		{%- set is_int = true %}
		{%- set is_signed = true %}
	{%- elif strong_t == "u32" %}
		{%- set is_int = true %}
		{%- set is_unsigned = true %}
	{%- elif strong_t == "i64" %}
		{%- set is_int = true %}
		{%- set is_signed = true %}
	{%- elif strong_t == "u64" %}
		{%- set is_int = true %}
		{%- set is_unsigned = true %}
	{%- elif strong_t == "f32" %}
		{%- set is_float = true %}
		{%- set is_signed = true %}
	{%- elif strong_t == "f64" %}
		{%- set is_float = true %}
		{%- set is_signed = true %}
	{%- endif %}
{%- elif is_float %}
	{%- set base_name = "FloatVec" %}
{%- elif is_int %}
	{%- if is_signed %}
		{%- set base_name = "SIntVec" %}
	{%- elif is_unsigned %}
		{%- set base_name = "UIntVec" %}
	{%- else %}
		{%- set base_name = "IntVec" %}
	{%- endif %}
{%- elif is_signed %}
	{%- set base_name = "SignedVec" %}
{%- else %}
	{%- set base_name = "GVec" %}
{%- endif -%}

use std::{
	fmt::{Debug, Display},
	iter::{Product, Sum},
	ops::{
		Add,
		AddAssign,
		Div,
		DivAssign,
		Index,
		IndexMut,
		Mul,
		MulAssign,
		Rem,
		RemAssign,
		Sub,
		SubAssign,
{%- if is_signed %}
		Neg,
{%- endif %}
{%- if is_int %}
		BitAnd,
		BitOr,
		BitXor,
		Not,
		Shl,
		Shr,
{%- endif %}
	},
};
{%- if not strong_t %}
use num_traits::{
	NumAssign,
	FromPrimitive,
	ToPrimitive,
	{%- if is_float %}
	Float,
	Signed,
	{%- elif is_int %}
	PrimInt,
		{%- if is_signed %}
	Signed,
		{%- elif is_unsigned %}
	Unsigned,
		{%- endif %}
	{%- elif is_signed %}
	Signed,
	{%- endif %}
};
{%- endif %}

{%- if dim %}
	{%- set name = base_name ~ dim %}
	{%- set components = ["x", "y", "z", "w"] | slice(end = dim) %}
	{%- set dim_minus_one = dim - 1 %}
	{%- set dim_plus_one = dim + 1 %}
	{%- if bvec_trait %}
use crate::GBVec{{ dim }};
		{%- set bvec_t = "Self::BVec" ~ dim ~ "Type" %}
	{%- else %}
		{%- set bvec_t = "glam::BVec" ~ dim %}
	{%- endif %}
	{%- if dim > 2 %}
use crate::{{ base_name ~ dim_minus_one }};
	{%- endif %}
	{%- if dim < 4 %}
use crate::{{ base_name ~ dim_plus_one }};
	{%- endif %}
{%- else %}
	{%- set name = base_name %}
use crate::GBVec;
	{%- set bvec_t = "Self::BVecType" %}
{%- endif %}

{%- if strong_t %}
	{%- set scalar_t = strong_t %}
{%- else %}
	{%- set scalar_t = "Self::Scalar" %}
{%- endif %}

pub trait {{ name }}
where
	for <'a> Self:
		Clone +
		Copy +
		PartialEq +
		Default +
		Div<Output = Self> +
		DivAssign +
		Div<{{ scalar_t }}, Output = Self> +
		DivAssign<{{ scalar_t }}> +
		Mul<Output = Self> +
		MulAssign +
		Mul<{{ scalar_t }}, Output = Self> +
		MulAssign<{{ scalar_t }}> +
		Add<Output = Self> +
		AddAssign +
		Add<{{ scalar_t }}, Output = Self> +
		AddAssign<{{ scalar_t }}> +
		Sub<Output = Self> +
		SubAssign +
		Sub<{{ scalar_t }}, Output = Self> +
		SubAssign<{{ scalar_t }}> +
		Rem<Output = Self> +
		RemAssign +
		Rem<{{ scalar_t }}, Output = Self> +
		RemAssign<{{ scalar_t }}> +
		Sum +
		Sum<&'a Self> +
		Product +
		Product<&'a Self> +
		Index<usize, Output = {{ scalar_t }}> +
		IndexMut<usize, Output = {{ scalar_t }}> +
		Display +
		Debug +
{%- if is_signed %}
		Neg +
{%- endif %}
{%- if is_int %}
		Eq +
		Not +
		BitAnd +
		BitAnd<{{ scalar_t }}> +
		BitOr +
		BitOr<{{ scalar_t }}> +
		BitXor +
		BitXor<{{ scalar_t }}> +
		Shl<i8> + Shr<i8> + Shl<u8> + Shr<u8> +
		Shl<i16> + Shr<i16> + Shl<u16> + Shr<u16> +
		Shl<i32> + Shr<i32> + Shl<u32> + Shr<u32> +
		Shl<i64> + Shr<i64> + Shl<u64> + Shr<u64> +
{%- endif %}
{%- if dim %}
		AsRef<[Self::Scalar; {{ dim }}]> +
		AsMut<[Self::Scalar; {{ dim }}]> +
		From<[Self::Scalar; {{ dim }}]> +
		Into<[Self::Scalar; {{ dim }}]> +
		From<({% for c in components %}Self::Scalar{% if not loop.last %}, {% endif %}{% endfor %})> +
		Into<({% for c in components %}Self::Scalar{% if not loop.last %}, {% endif %}{% endfor %})> +
	{%- if dim > 2 %}
		From<(Self::{{ base_name ~ dim_minus_one }}Type, Self::Scalar)> +
	{%- endif %}
{%- endif %}
	,
{%- if not strong_t %}
	Self::Scalar:
		Div<Self, Output = Self> +
		Mul<Self, Output = Self> +
		Add<Self, Output = Self> +
		Sub<Self, Output = Self> +
		Rem<Self, Output = Self> +
		Copy +
		PartialOrd +
		NumAssign +
		FromPrimitive +
		ToPrimitive +
	{%- if is_float %}
		Float +
		Signed +
	{%- elif is_int %}
		PrimInt +
		{%- if is_signed %}
		Signed +
		{%- elif is_unsigned %}
		Unsigned +
		{%- endif %}
	{%- elif is_signed %}
		Signed +
	{%- endif %}
	,
{%- endif %}
{%- if dim %}
	{%- if bvec_trait %}
	Self::BVec{{ dim }}Type: GBVec{{ dim }},
	{%- endif %}
	{%- if dim > 2 %}
	Self::{{ base_name ~ dim_minus_one }}Type: {{ base_name ~ dim_minus_one }}<Scalar = Self::Scalar>,
	{%- endif %}
	{%- if dim < 4 %}
	Self::{{ base_name ~ dim_plus_one }}Type: {{ base_name ~ dim_plus_one }}<Scalar = Self::Scalar>,
	{%- endif %}
{%- else %}
	Self::BVecType: GBVec,
{%- endif %}
{
{%- if not strong_t %}
	type Scalar;
{%- endif %}
{%- if dim %}
	{%- if bvec_trait %}
	type BVec{{ dim }}Type;
	{%- endif %}
	{%- if dim > 2 %}
	type {{ base_name ~ dim_minus_one }}Type;
	{%- endif %}
	{%- if dim < 4 %}
	type {{ base_name ~ dim_plus_one }}Type;
	{%- endif %}
{%- else %}
	type BVecType;
{%- endif %}
	const ZERO: Self;
	const ONE: Self;
{%- if is_signed %}
	const NEG_ONE: Self;
{%- endif %}
	const MIN: Self;
	const MAX: Self;
{%- if is_float %}
	const NAN: Self;
	const INFINITY: Self;
	const NEG_INFINITY: Self;
{%- endif %}
{%- if dim %}
	{%- for c in components %}
	const {{ c | upper }}: Self;
	{%- endfor %}
	{%- if is_signed %}
		{%- for c in components %}
	const NEG_{{ c | upper }}: Self;
		{%- endfor %}
	{%- endif %}
	const AXES: [Self; {{ dim }}];
{%- else %}
	const DIM: usize;
{%- endif %}
	fn splat(v: {{ scalar_t }}) -> Self;
	fn from_slice(slice: &[{{ scalar_t }}]) -> Self;
	fn write_to_slice(self, slice: &mut [{{ scalar_t }}]);
	fn dot(self, rhs: Self) -> {{ scalar_t }};
	fn dot_into_vec(self, rhs: Self) -> Self;
	fn min(self, rhs: Self) -> Self;
	fn max(self, rhs: Self) -> Self;
	fn clamp(self, min: Self, max: Self) -> Self;
	fn min_element(self) -> {{ scalar_t }};
	fn max_element(self) -> {{ scalar_t }};
	fn select(mask: {{ bvec_t }}, if_true: Self, if_false: Self) -> Self;
	fn cmpeq(self, rhs: Self) -> {{ bvec_t }};
	fn cmpne(self, rhs: Self) -> {{ bvec_t }};
	fn cmpge(self, rhs: Self) -> {{ bvec_t }};
	fn cmpgt(self, rhs: Self) -> {{ bvec_t }};
	fn cmple(self, rhs: Self) -> {{ bvec_t }};
	fn cmplt(self, rhs: Self) -> {{ bvec_t }};
	fn length_squared(self) -> {{ scalar_t }};
{%- if is_signed %}
	fn abs(self) -> Self;
	fn signum(self) -> Self;
	fn is_negative_bitmask(self) -> u32;
	fn distance_squared(self, rhs: Self) -> {{ scalar_t }};
	fn div_euclid(self, rhs: Self) -> Self;
	fn rem_euclid(self, rhs: Self) -> Self;
{%- endif %}
{%- if is_float %}
	fn copysign(self, rhs: Self) -> Self;
	fn is_finite(self) -> bool;
	fn is_nan(self) -> bool;
	fn length(self) -> {{ scalar_t }};
	fn length_recip(self) -> {{ scalar_t }};
	fn distance(self, rhs: Self) -> {{ scalar_t }};
	fn normalize(self) -> Self;
	fn try_normalize(self) -> Option<Self>;
	fn normalize_or_zero(self) -> Self;
	fn is_normalized(self) -> bool;
	fn project_onto(self, rhs: Self) -> Self;
	fn reject_from(self, rhs: Self) -> Self;
	fn project_onto_normalized(self, rhs: Self) -> Self;
	fn reject_from_normalized(self, rhs: Self) -> Self;
	fn round(self) -> Self;
	fn floor(self) -> Self;
	fn ceil(self) -> Self;
	fn trunc(self) -> Self;
	fn fract(self) -> Self;
	fn exp(self) -> Self;
	fn powf(self, n: {{ scalar_t }}) -> Self;
	fn recip(self) -> Self;
	fn lerp(self, rhs: Self, s: {{ scalar_t }}) -> Self;
	fn abs_diff_eq(self, rhs: Self, max_abs_diff: {{ scalar_t }}) -> bool;
	fn clamp_length(self, min: {{ scalar_t }}, max: {{ scalar_t }}) -> Self;
	fn clamp_length_max(self, max: {{ scalar_t }}) -> Self;
	fn clamp_length_min(self, min: {{ scalar_t }}) -> Self;
	fn mul_add(self, a: Self, b: Self) -> Self;
{%- endif %}
{%- if is_int %}
	fn wrapping_add(self, rhs: Self) -> Self;
	fn wrapping_sub(self, rhs: Self) -> Self;
	fn wrapping_mul(self, rhs: Self) -> Self;
	fn wrapping_div(self, rhs: Self) -> Self;
	fn saturating_add(self, rhs: Self) -> Self;
	fn saturating_sub(self, rhs: Self) -> Self;
	fn saturating_mul(self, rhs: Self) -> Self;
	fn saturating_div(self, rhs: Self) -> Self;
{%- endif %}
{%- if dim %}
	fn new({% for c in components %}{{ c }}: Self::Scalar{% if not loop.last %}, {% endif %}{% endfor %}) -> Self;
	fn from_array(a: [Self::Scalar; {{ dim }}]) -> Self;
	fn to_array(&self) -> [Self::Scalar; {{ dim }}];
	{%- if dim < 4 %}
	fn extend(self, v: Self::Scalar) -> Self::{{ base_name ~ dim_plus_one }}Type;
	{%- endif %}
	{%- if dim > 2 %}
	fn truncate(self) -> Self::{{ base_name ~ dim_minus_one }}Type;
	{%- endif %}
	{%- if dim == 3 %}
	fn cross(self, rhs: Self) -> Self;
	{%- endif %}
	{%- if is_signed %}
		{%- if dim == 2 %}
	fn perp(self) -> Self;
	fn perp_dot(self, rhs: Self) -> Self::Scalar;
	fn rotate(self, rhs: Self) -> Self;
		{%- endif %}
	{%- endif %}
	{%- if is_float %}
	fn is_nan_mask(self) -> {{ bvec_t }};
		{%- if dim < 4 %}
	fn angle_between(self, rhs: Self) -> Self::Scalar;
		{%- endif %}
		{%- if dim == 2 %}
	fn from_angle(angle: Self::Scalar) -> Self;
	fn to_angle(self) -> Self::Scalar;
		{%- elif dim == 3 %}
	fn any_orthogonal_vector(&self) -> Self;
	fn any_orthonormal_vector(&self) -> Self;
	fn any_orthonormal_pair(&self) -> (Self, Self);
		{%- endif %}
	{%- endif %}
{%- endif %}
}
